#!/bin/bash
set -e # Exit immediately if a command exits with a non-zero status

if [ -z "$1" ] || [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
  >&2 echo "Usage: $(basename "$0") Image"
  exit 1
fi

# --- Dependency Check for pishrink.sh ---
if ! command -v pishrink.sh &> /dev/null; then
  echo "pishrink.sh not found. Attempting to install..."
  PISHRINK_URL="https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh"
  # Download the script and pipe it to the 'install' command
  if curl -sL "${PISHRINK_URL}" | sudo install /dev/stdin /usr/local/bin/pishrink.sh; then
    echo "pishrink.sh installed successfully to /usr/local/bin."
  else
    echo "Failed to install pishrink.sh. Please install it manually." >&2
    exit 1
  fi
fi

INPUT_FILE="$1"
# This will be the .img file we operate on
WORK_FILE=""

# --- PHASE 1: Prepare Input File ---
echo "--- Checking input file type ---"
case "$INPUT_FILE" in
  *.xz)
    echo "XZ compressed image detected. Decompressing..."
    xz -dk "$INPUT_FILE"
    WORK_FILE="${INPUT_FILE%.xz}"
    ;;
  *.gz)
    echo "Gzip compressed image detected. Decompressing..."
    gunzip -k "$INPUT_FILE"
    WORK_FILE="${INPUT_FILE%.gz}"
    ;;
  *.bz2)
    echo "Bzip2 compressed image detected. Decompressing..."
    bunzip2 -k "$INPUT_FILE"
    WORK_FILE="${INPUT_FILE%.bz2}"
    ;;
  *.img)
    echo "Uncompressed image detected."
    WORK_FILE="$INPUT_FILE"
    ;;
  *)
    echo "Error: Unrecognized file type: $INPUT_FILE" >&2
    exit 1
    ;;
esac

echo "Working on: ${WORK_FILE}"


# --- PHASE 1: Modify the image inside a self-contained subshell ---
(
  MOUNT_POINT="/mnt/image_root"
  LOOP_DEVICE=""

  # This cleanup function is local to the subshell
  cleanup() {
    echo "--- Cleaning up modification phase ---"
    if mountpoint -q "${MOUNT_POINT}"; then
      sudo umount "${MOUNT_POINT}"
    fi
    if [ -n "${LOOP_DEVICE}" ]; then
      sudo losetup -d "${LOOP_DEVICE}"
    fi
  }

  trap cleanup EXIT

  echo "--- Modifying image ---"
  LOOP_DEVICE=$(sudo losetup -fP --show "${WORK_FILE}")
  ROOT_PARTITION="${LOOP_DEVICE}p2"

  sudo mkdir -p "${MOUNT_POINT}"
  sudo mount "${ROOT_PARTITION}" "${MOUNT_POINT}"

  # Inject the self-expanding service for Arch Linux
  echo "Installing one-shot resize service..."
  # Create the script file
  sudo tee "${MOUNT_POINT}/usr/local/sbin/resize-fs-once.sh" > /dev/null <<'EOF'
#!/bin/bash
fdisk /dev/mmcblk0 <<END
d
2
n
p
2


N
w
END
partprobe /dev/mmcblk0
resize2fs /dev/mmcblk0p2
systemctl disable resize-fs-once.service
rm /etc/systemd/system/resize-fs-once.service
rm /usr/local/sbin/resize-fs-once.sh
rm -f /etc/rc.local
EOF

  # Create the service file
  sudo tee "${MOUNT_POINT}/etc/systemd/system/resize-fs-once.service" > /dev/null <<'EOF'
[Unit]
Description=Resize Root Filesystem Once
[Service]
Type=oneshot
ExecStart=/usr/local/sbin/resize-fs-once.sh
[Install]
WantedBy=multi-user.target
EOF

  # Make the script executable
  sudo chmod +x "${MOUNT_POINT}/usr/local/sbin/resize-fs-once.sh"

  # Enable the service by creating the symlink
  sudo ln -sf /etc/systemd/system/resize-fs-once.service "${MOUNT_POINT}/etc/systemd/system/multi-user.target.wants/resize-fs-once.service"

  # --- START OF CLEANUP SYNCHRONIZATION ---

  # --- Remove personal SSH public key ---
  if [ -f "${MOUNT_POINT}/home/audiolinux/.ssh/authorized_keys" ]; then
    echo "Removing SSH public key..."
    sudo rm -fv "${MOUNT_POINT}/home/audiolinux/.ssh/authorized_keys"
  fi

  # --- Restore default pacman mirrorlist ---
  echo "Restoring default pacman mirrorlist..."
  MIRROR_FILE="${MOUNT_POINT}/etc/pacman.d/mirrorlist"
  DEFAULT_MIRROR="http://mirror.archlinuxarm.org/\$arch/\$repo"
  CUSTOM_MIRROR="http://ca.us.mirror.archlinuxarm.org/\$arch/\$repo"
  if [ -f "$MIRROR_FILE" ]; then
    sudo sed -i "s|# *Server = ${DEFAULT_MIRROR}|Server = ${DEFAULT_MIRROR}|" "$MIRROR_FILE"
    sudo sed -i "s|^Server = ${CUSTOM_MIRROR}|# Server = ${CUSTOM_MIRROR}|" "$MIRROR_FILE"
  fi

  # Remove the machine-id to generalize the image
  if [ -f "${MOUNT_POINT}/etc/machine-id" ]; then
    echo "Removing existing machine-id..."
    sudo rm "${MOUNT_POINT}/etc/machine-id"
    sudo touch "${MOUNT_POINT}/etc/machine-id"
  fi

  # Remove the Roon IDs to generalize the image
  echo "Removing Roon unique identifiers..."
  sudo rm -fv "${MOUNT_POINT}/var/roon/RoonBridge/Settings/unique_id"
  sudo rm -fv "${MOUNT_POINT}/var/roon/RAATServer/Settings/unique_id"
  sudo rm -fv "${MOUNT_POINT}"/var/roon/*/Settings/*.json
  sudo rm -fv "${MOUNT_POINT}/home/audiolinux/roon-ir-remote/.roon-token"

  # --- Clean up root's Bash history ---
  if [ -f "${MOUNT_POINT}/root/.bash_history" ]; then
    echo "Cleaning up root user's Bash history..."
    # Use sh -c for redirection with sudo
    sudo truncate --size 0 "${MOUNT_POINT}/root/.bash_history"
  fi

  # --- Clean up audiolinux user's Bash history ---
  if [ -f "${MOUNT_POINT}/home/audiolinux/.bash_history" ]; then
    echo "Cleaning up audiolinux user's Bash history..."
    sudo truncate --size 0 "${MOUNT_POINT}/home/audiolinux/.bash_history"
  fi

  # --- END OF CLEANUP SYNCHRONIZATION ---

  if [ -d "${MOUNT_POINT}/opt/diretta-alsa-target" ]; then
    dl=$(find "${MOUNT_POINT}/opt/diretta-alsa-target" ! -name 'diretta*')
    if [ -n "${dl}" ]; then
      echo "- Diretta License File Found."
      sudo mv -v "${dl}" "${WORK_FILE%.img}".lic
    fi
  fi
) # The subshell now exits, and its trap automatically cleans up mounts/loops.

# --- PHASE 2: Shrink the fully prepared and unmounted image ---
echo "--- Shrinking image ---"
sudo pishrink.sh "${WORK_FILE}"

echo "Image is now prepared and ready to be compressed."
